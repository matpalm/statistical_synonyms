this is work in progress
see http://matpalm.com/blog/tag/e12/ for more as i fill it out

zcat /data/twitter/gardenhose/sample.20091116.json.gz | head -1000 | tweet_text.rb | sanitise.rb > sample.tweets

text = load 'sample.tweets';
ngrams = stream text through `ruby n_grams.rb 3` as (f1:chararray, f2:chararray, f3:chararray);

raw data
x1 a y1
x1 b y1
x1 a y1
x1 d y1
x2 a y2
x2 c y2
x2 b y2
x2 b y2
x1 d y1

freqs
ngrams_grouped = group ngrams by (f1,f2,f3);
freqs = foreach ngrams_grouped generate flatten(group), SIZE(ngrams) as freq;
(x1,a,y1,2L)
(x1,b,y1,1L)
(x1,d,y1,2L)
(x2,a,y2,1L)
(x2,b,y2,2L)
(x2,c,y2,1L)

middle_values = group freqs by (f1,f3);
middle_values2 = foreach middle_values generate group, freqs.f2, freqs.freq;
((x1,y1),{(a),(b),(d)},{(2L),(1L),(2L)})
((x2,y2),{(a),(b),(c)},{(1L),(2L),(1L)})

exploded = stream middle_values2 through `ruby explode_combos.rb` as (s1:chararray, s2:chararray, weight:float);
this step has to be a udf, or stream out to ruby
a b 2/1 0.5  *
a d 2/2 1.0
b d 1/2 0.5
a b 1/2 0.5  *
a c 1/1 1.0
b c 2/1 0.5

exploded_grouped = group exploded by (s1,s2);
exploded_mean = foreach exploded_grouped generate flatten(group), AVG(exploded.weight);

a b 0.5
a c 1.0     
a d 1.0      
b c 0.5     
b d 0.5  
TODO: weight these on the relative frequency of x1, x2, y1 and y2


